---
title: "All about 'Class'"
date: "2020-03-25T22:40:32.169Z"
template: "post"
draft: false
slug: "python-class"
category: "Python"
tags:
  - "python"
  - "class"
description: "파이썬 클래스에 대해 자세히 알아보자."
socialImage: "#"
---
클래스를 쓰기는 썼는데, 그래서 제대로 알고는 있는가? 클래스에 대해 자세히 알아보고자 한다.   

## 클래스는 무엇?
- 클래스를 이용하면 새로운 타입을 만들 수 있는데 우리가 배운 정수, 실수, 문자열, 리스트, 튜플과 같은 가본 자료형과 기본 자료구조도 모두 클래스를 통해 이미 만들어진 타입이다. 
- 객체지향 프로그래밍은 객체를 정의하는 것에서부터 시작한다. 파이썬에서는 함수도 객체이다. 
- 우리가 함수를 사용하기 전에 def로 먼저 정의해주었듯이, 클래스도 먼저 정의해줘야한다. 
- 클래스를 사용하는 목적은 변수와 함수를 묶어서 새로운 객체 타입을 만드는 것에 있다. 
- 클래스를 정의해준다는 것은 새로운 데이터 타입을 정의한 것이기 때문에 이를 실제로 사용하려면 '인스턴스'라는 것을 생성해야한다.   
- 예시)
![](/media/스크린샷 2020-04-03 오후 1.16.31.png)

- 파이썬에서 정의된 클래스를 이용해 인스턴스를 생성하려면 위와 같이 클래스명 뒤에 ()를 붙여주면 된다. 첫번째 줄을 실행하면 'BusinessCard'라는 클래스의 인스턴스가 메모리의 0x10deb8c90 위치에 생성되고 card1이라는 변수가 이를 바인딩한다. 

## 클래스에 method 추가하기   
- 앞에서 정의한 클래스 내부에는 함수나 변수가 없어서 인스턴스를 만들어도 인스턴스로 할 수 있는 일이 별로 없다. 그래서 클래스에 사용자로부터 데이터를 입력받고 이를 저장하는 기능을 수행하는 함수를 넣어보고자 한다. 클래스 내부에 있는 함수를 특별히 '메서드'라고 한다. 
```python   
class BusinessCard:
    def set_info(self, name, email, addr):
        self.name = name
        self.email = email
        self.addr = addr
```     
- self의 의미에 대해서는 후에 자세히 다뤄보고자 한다. 우선은 메서드의 첫번째 인자는 반드시 self여야 한다. 
- 위 코드를 보면, 메서드 인자로 전달된 name, email, addr 값을 각각 self.name, self.email, self.addr 이라는 변수에 대입하는 것을 볼 수 있고 이러한 대입은 바인딩을 의미한다. 
- set_info 메서드의 동작은 메서드 인자인 name, email, addr이라는 변수가 가리키던 값을 self.name, self.email, self.addr이 바인딩하는 것이다.   
- 우선 self를 제외하고 세개의 인자만 set_info 메서드의 입력값으로 전달한다. 입력을 하면 set_info 메서드는 메서드 인자로 전달된 값을 바인딩했다는 것이고, 현재 사용가능한 변수는 클래스 인스턴스인 member1 하나 뿐이다. 
- 예시)
![](/media/스크린샷 2020-04-03 오후 2.30.58.png)
- 'self.변수명'형태로 되어있는 변수를 인스턴스 변수라고 한다. 이는 클래스 인스턴스 내부의 변수를 의미한다. member1이라는 인스턴스를 생성하고 함수를 호출하면 내부의 인스턴스변수들이 바인딩하는 것이다. 클래스를 정의하는 순간 우리가 지정한 변수가 member1인지 모르기 때문에 self라는 단어를 대신 사용하는 것이다. 
- 즉, set_info 메소드 내에서 self.name 이라는 표현은 나중에 생성될 인스턴스 내의 name 변수를 의미한다. 
- 이처럼, 클래스는 한번 정의해두면 여러 클래스 인스턴스를 만들 수 있다. 
- print_info 메서드를 추가해서 self.name을 통해 바로 데이터에 접근할 수 있다. 이미 메서드를 정의해놓았기 때문에 메서드를 호출해 출력할 수 있다. 
- 예시)
![](/media/스크린샷 2020-04-03 오후 2.49.25.png)

## 클래스 생성자   
- 파이썬 클래스에는 인스턴스 생성과 동시에 자동으로 호출되는 메서드인 생성자가 존재한다. 
- 파이썬에서는 ```__init__(self)``` 와 같은 이름의 메서드를 생성자라고 하고, 클래스에서 __로 시작하는 함수는 모두 특별한 메서드이다. 
- 예시)
```python
class MyClass:
    def __init__(self):
        print("객체가 생성되었습니다.")
inst1 = MyClass()
객체가 생성되었습니다.
```    

- MyClass라는 클래스를 정의하고 인스턴스를 생성하면 화면에 바로 출력이 된다. 이는 인스턴스가 생성되는 시점에 자동으로 ```__init__(self)``` 메소드가 실행되었기 때문이다. 
- 기존에 만들었던 BusinessCard 클래스를 새롭게 정의해보자. 
- 예시)
![](/media/스크린샷 2020-04-03 오후 4.41.18.png)
- 새로 정의된 클래스는 생성자에서 3개의 인자를 받기 때문에 3개의 인자를 전달해야 제대로 인스턴스가 생성된다. 이렇게 생성자를 사용하면 인스턴스의 생성과 초기값 저장을 한번에 할 수 있다. 

## self 이해하기   
- 예시)
![](/media/스크린샷 2020-04-03 오후 6.38.06.png)
- 파이썬 내장함수인 id를 이용해 인스턴스가 메모리에 할당된 주솟값을 확인해보았다. Foo 클래스를 새로 정의한다. func2 메서드가 호출될 때 메서드의 인자로 전달되는 self의 id 값을 화면에 출력하는 기능이 추가됐다.
- 인스턴스 f를 이용해 func2메서드를 호출해보았다. id(self)의 값과 f라는 변수가 바인딩하고 있는 인스턴스의 주솟값이 동일하다. 즉, 클래스 내에 정의된 self는 클래스 인스턴스임을 알 수 있다. 
- 파이썬의 클래스는 그 자체가 하나의 네임스페이스이기 때문에 인스턴스 생성과 상관없이 클래스 내의 메서드를 직접 호출할 수 있다.   
- func1 메서드를 호출했지만 앞서 인스턴스를 통해 메서드를 호출했던 것과는 달리 오류가 발생하지 않는 것을 확인할 수 있다. 왜냐하면 인스턴스.메서드() 형태로 호출한 것과 달리 이번에는 클래스명.메서드() 형태로 호출했기 때문이다.
- self 위치에 인자를 전달하지 않고 메서드를 호출하면 오류가 발생한다. 오류 메시지를 확인하면 func2()를 호출할 때 인자를 하나 전달해야 하는데 전달하지 않아서 오류가 발생한 것이다.
- 앞에서 메서드의 self로 전달되는 것은 인스턴스 자체라고 설명했다. 따라서 클래스에 대한 인스턴스를 생성한 후 해당 인스턴스를 전달하면 된다.

클래스와 인스턴스의 차이를 이해하려면 네임스페이스에 대한 개념을 알아야 한다. 

## 네임스페이스 (Namespace)
- 네임스페이스는 변수가 객체를 바인딩할 때 그 둘 사이의 관계를 저장하고 있는 공간을 의미한다. 예를 들어, 'a = 2'라고 했을 때 a라는 변수가 2라는 객체가 저장된 주소를 가지고 있는 것이다. 그러한 연결 관계가 저장된 공간이 바로 네임스페이스이다.   
- 예시를 통해 더 알아보자.
![](/media/스크린샷 2020-04-04 오전 11.17.44.png)
- 먼저 Stock이라는 클래스를 정의해보았다. dir내장함수를 이용해 리스트로 된 반환값들도 확인해보았다. 
- dir 내장함수 결과값에 Stock 클래스가 들어있기 때문에 프롬프트에 Stock을 입력해도 오류가 나지 않는다. 그치만 존재하지 않는 값을 입력하면 당연히 오류가 나타난다. 
- 파이썬에서는 클래스가 정의되면 하나의 독립적인 네임스페이스가 생성된다. 그리고 클래스 내에 정의된 변수나 메서드는 해당 네임스페이스 안에 파이썬 딕셔너리 타입으로 저장된다. 
- Stock 클래스는 Stock이라는 네임스페이스 안에 'market':'kospi'라는 값을 가진 딕셔너리를 포함한다.
- 이것을 파이썬 코드로 확인하려면 ```__dict__``` 속성을 이용하여 확인할 수 있다. 
- 클래스가 독립적인 네임스페이스를 가지고 클래스 내의 변수나 메서드를 네임스페이스에 저장하고 있으므로 다음과 같이 클래스 내의 변수에 접근할 수 있는 것이다.   
```python
>>> Stock.market
'kospi'
```   

- s1, s2라는 서로 다른 두 개의 인스턴스를 생성해보았다. 생성된 인스턴스에 대한 id 값을 확인해보면 두 인스턴스가 서로 다른 메모리에 위치하는 것을 알 수 있다. 파이썬은 인스턴스를 생성하면 인스턴스별로 별도의 네임스페이스를 유지한다. 
- 코드를 보면 s1, s2의 네임페이스가 {}로 비어있음을 알 수 있다. s1 인스턴스에 market이라는 변수를 추가했더니 'market':'kosdaq' 이라는 키:값 쌍이 생성되었다. 현재 s2 인스턴스는 비어있다. 
- 두 인스턴스 모두 변수에 접근해보면, s1은 kosdaq을 반환하는데 s2는 kospi를 반환하였다. 
- 그 이유는 s2 인스턴스를 통해 변수에 접근하면 파이썬은 먼저 s2 인스턴스의 네임스페이스에서 해당 변수가 존재하는지 찾는다. s2의 네임스페이스에 해당 변수가 존재하지 않으면 s2 인스턴스의 클래스의 네임스페이스로 가서 다시 변수를 찾게 된다. 
![](/media/스크린샷 2020-04-04 오전 11.36.47.png)

## 클래스변수와 인스턴스 변수
이번에는 가장 헷갈렸던 클래스 변수와 인스턴스 변수에 대해 알아보고자 한다. 

- 우선 Account라는 클래스를 만들었고 이 클래스 안에는 생성자와 소멸자가 있다. 
```python
>>>class Account:
        def __init__(self, name):
            self.name = name
            Accounts.num_accounts += 1
        def __del__(self):
            Accounts.num_accounts -= 1
```   
- num_accounts처럼 클래스 내부에 선언된 변수를 클래스 변수라고 하며, self.name과 같이 self가 붙어 있는 변수를 인스턴스 변수라고 한다. 
- 클래스 변수는 Account 클래스의 네임스페이스에 위치하며, self.name과 같은 인스턴스 변수는 인스턴스의 네임스페이스에 위치하게 된다. 
- 예시)
![](/media/스크린샷 2020-04-04 오후 12.22.30.png)
- Account 클래스의 인스턴스를 생성한다.
- 그렇다면 지금까지 은행에서 개설된 계좌는 총 몇 개인가? 정답은 'kim'과 'lee'에게 하나씩 개설됐기 때문에 두 개이다. kim 인스턴스나 lee 인스턴스를 통해 num_accounts라는 이름에 접근하면 총 계좌 개설 개수가 2개로 나오는것을 알 수 있다.
-  kim.num_accounts에서 먼저 인스턴스의 네임스페이스에서 num_accounts를 찾았지만 해당 이름이 없어서 클래스의 네임스페이스로 이동한 후 다시 해당 이름을 찾았고 그 값이 반환된 것임을 알 수 있다.
- 이처럼 여러 인스턴스 간에 서로 공유해야 하는 값은 클래스 변수를 통해 바인딩해야 한다. 왜냐하면 파이썬은 인스턴스의 네임스페이스에 없는 이름은 클래스의 네임스페이스에서 찾아보기 때문에 이러한 특성을 이용하면 클래스 변수가 모든 인스턴스에 공유될 수 있기 때문이다. 참고로 클래스 변수에 접근할 때 클래스 이름을 사용할 수도 있다. 

![](/media/스크린샷 2020-04-04 오후 12.49.06.png)

##### 참고: <파이썬으로 배우는 알고리즘 트레이딩>

