---
title: "Bcrypt로 비밀번호 암호화하기"
date: "2020-03-05T22:12:03.284Z"
template: "post"
draft: false
slug: "비밀번호-암호화"
category: "Computer Science"
tags:
  - "password hashing"
  - "bcrypt"
  - "salting"
  - "rainbow table"
description: "비밀번호를 안전하게 저장하려면 어떻게 해야될까?"
socialImage: "#"
---

## 비밀번호 암호화를 해야하는 이유   
- 당연한 얘기지만, 서버의 데이터베이스가 털려도 사용자의 비밀번호를 알 수 없게 하기 위해서이다. 비밀번호가 잘 해싱이 되어있으면 해커가 그 해시값을 보더라도 사용자 계정으로 로그인할 수 없기 때문에 의미없는 정보가 된다.   
- 암호화(Encryption) : 평문을 암호문으로 변환하는 과정   
Ex) 평문("123456") → 암호화 → 암호문("aBD#fefa$fae!")   
- 복호화(Decryption) : 암호문을 평문으로 변환하는 과정   
Ex) 암호문("aBD#fefa$fae!!") → 복호화 → 평문("123456")

### 해시란?   
- 해시는 임의의 크기를 가진 데이터를 고정된 데이터의 크기로 변환시키는 것을 말한다.   
- 해시는 보안 분야에서도 널리 사용되는데 이는 해시 함수가 원래의 문장을 복호화할 수 없게 뭉개버린다는 장점, 그리고 원문과 해시값 사이에 선형적 관계가 없다는 특성을 지니고 있기 때문이다. 해시 함수의 결과물은 고정된 길이의 숫자이므로, 원래의 정보는 손실된다.   

### 양방향보다는 단방향 암호화  
- 양방향 암호화는 암호화된 비밀번호를 평문으로 복호화할 수 있는 암호화를 말한다. 반대로 단방향 암호화는 평문을 암호문으로 암호화할 수는 있지만, 암호문을 평문으로 복호화하는 것은 불가능한 암호화이다.   
- 그렇다면 왜 단방향 암호화를 해야하는 것일까? 그 이유는 비밀번호를 평문으로 저장하지 않는 이유와 같다. 양방향 암호화는 알고리즘과 키값만 노출되면 바로 복호화가 가능하다. 서버가 해킹 당한 상황이면 소스코드도 다 노출된 상황이므로 알고리즘과 키값 모두 노출된 상황이나 마찬가지다. 그리고 역시 위에서 언급한 것과 마찬가지로 내부 개발자는 이미 알고리즘과 키, 데이터베이스에 모두 접근이 가능하므로 원하면 언제든 사용자의 패스워드를 볼 수 있다. 그래서, 패스워드 보안에서 양방향 암호화는 별 의미가 없다.   

## Bcrypt

### 단방향 암호화에도 취약점이 있다   
- 미리 해시값들을 계산해 놓은 테이블을 'Rainbow Table'이라고 하는데 이의 공격을 받을 수 있다.   
- 해시 함수는 원래 패스워드를 저장하기 위해서 설계된 것이 아니라 짧은 시간에 데이터를 빠르게 검색하기 위해 설계된 것이다. 이러한 속성 때문에 공격자는 매우 빠른 속도로 임의의 문자열의 다이제스트와 해킹할 대상의 다이제스트를 비교할 수 있다(MD5를 사용한 경우 일반적인 장비를 이용하여 1초당 56억 개의 다이제스트를 대입할 수 있다). 이런 방식으로 패스워드를 추측하면 패스워드가 충분히 길거나 복잡하지 않은 경우에는 그리 긴 시간이 걸리지 않는다 (대부분 사용자의 패스워드는 길거나 복잡하지 않을 뿐 아니라, 동일한 패스워드를 사용하는 경우도 많다).   

### Salting & Key Stretching   
취약점을 보완하기 나온 개념들이다.   
- Salting: 음식에 맛을 더하기 위해 소금을 치듯이, 실제 비밀번호에 랜덤한 값을 더해서 해시값을 계산하는 방법.   
- Key stretching: 단방향 해쉬값을 계산한 후, 그 값을 또 해시하고, 다시 이를 또 반복하는 작업이다.   
- 이 두가지를 구현한 해시함수가 바로 bcrypt이다. bcrypt는 처음부터 비말번호를 단방향으로 암호화하기 위해 만들어진 해시함수이다. 입력값을 72 byte로 해야 해서 조금 귀찮다 하지만 가장 많이 쓰인다.   

```python
import bcrypt

bcrypt.hashpw(b"secrete password", bcrypt.gensalt())
b'$2b$12$.XIJKgAepSrI5ghrJUaJa.ogLHJHLyY8ikIC.7gDoUMkaMfzNhGo6'

bcrypt.hashpw(b"secrete password", bcrypt.gensalt()).hex()
'243262243132242e6b426f39757a69666e344f563852694a43666b5165445469397448446c4d366635613542396847366d5132446d62744b70357353'
```   

#### 다른 해싱 알고리즘들에 대해 알아보고 싶다면 비교해놓은 사이트가 있으니 참고해보면 좋을 것이다.   
https://damianhodgkiss.com/articles/most-secure-password-hashing-algorithms/

##### 참조:   
https://sieunlim.tistory.com/16   
http://www.codeok.net/패스워드%20보안의%20기술



